import { existsSync, readFileSync } from 'node:fs'
import { join } from 'node:path'
import * as R from 'ramda'

/**
 * Category metadata configuration matching Docusaurus's _category_.json/yml format.
 * @see https://docusaurus.io/docs/sidebar/autogenerated#category-item-metadata
 */
export interface CategoryMetadata {
  /**
   * The display label for the category.
   */
  label?: string
  /**
   * Position for ordering within the sidebar.
   * Lower numbers appear first.
   */
  position?: number
  /**
   * Whether the category can be collapsed.
   * @default true
   */
  collapsible?: boolean
  /**
   * Whether the category is collapsed by default.
   * @default true
   */
  collapsed?: boolean
  /**
   * CSS class name(s) to apply to the category.
   */
  className?: string
  /**
   * Custom properties for advanced customization.
   */
  customProps?: Record<string, unknown>
  /**
   * Link configuration for category index pages.
   */
  link?: {
    type: 'generated-index' | 'doc'
    id?: string
    title?: string
    description?: string
    slug?: string
  } | null
}

/**
 * Cache for category metadata to avoid repeated file reads.
 */
const categoryMetadataCache = new Map<string, CategoryMetadata | null>()

/**
 * Parse JSON content safely, returning null on error.
 */
const parseJsonSafely = (content: string): CategoryMetadata | null => {
  try {
    return JSON.parse(content) as CategoryMetadata
  } catch {
    return null
  }
}

/**
 * Parse YAML content to extract category metadata.
 * This is a simple YAML parser for flat key-value structures.
 */
const parseYamlSafely = (content: string): CategoryMetadata | null => {
  try {
    const lines = content.split('\n')
    const result: Record<string, unknown> = {}

    for (const line of lines) {
      const trimmed = line.trim()
      // Skip comments and empty lines
      if (trimmed.startsWith('#') || trimmed === '') continue

      const colonIndex = trimmed.indexOf(':')
      if (colonIndex === -1) continue

      const key = trimmed.slice(0, colonIndex).trim()
      let value: unknown = trimmed.slice(colonIndex + 1).trim()

      // Parse value types
      if (value === 'true') value = true
      else if (value === 'false') value = false
      else if (value === 'null') value = null
      else if (/^-?\d+$/.test(value as string))
        value = parseInt(value as string, 10)
      else if (/^-?\d+\.\d+$/.test(value as string))
        value = parseFloat(value as string)
      // Remove quotes from strings
      else if (
        (value as string).startsWith('"') &&
        (value as string).endsWith('"')
      ) {
        value = (value as string).slice(1, -1)
      } else if (
        (value as string).startsWith("'") &&
        (value as string).endsWith("'")
      ) {
        value = (value as string).slice(1, -1)
      }

      result[key] = value
    }

    return result as CategoryMetadata
  } catch {
    return null
  }
}

/**
 * Read category metadata from a _category_.json or _category_.yml file in a directory.
 * Returns null if no category metadata file exists.
 *
 * @param dirPath - Absolute path to the directory to check for category metadata
 * @returns Category metadata or null if not found
 */
export const readCategoryMetadata = (
  dirPath: string,
): CategoryMetadata | null => {
  // Check cache first
  if (categoryMetadataCache.has(dirPath)) {
    return categoryMetadataCache.get(dirPath) ?? null
  }

  // Try _category_.json first, then _category_.yml, then _category_.yaml
  const filenames = ['_category_.json', '_category_.yml', '_category_.yaml']

  for (const filename of filenames) {
    const filePath = join(dirPath, filename)
    if (existsSync(filePath)) {
      const content = readFileSync(filePath, 'utf-8')
      const metadata = filename.endsWith('.json')
        ? parseJsonSafely(content)
        : parseYamlSafely(content)

      categoryMetadataCache.set(dirPath, metadata)
      return metadata
    }
  }

  categoryMetadataCache.set(dirPath, null)
  return null
}

/**
 * Build a map of category paths to their metadata.
 * Takes a base docs directory and scans for _category_ files.
 *
 * @param basePath - The base path of the docs directory
 * @param docPaths - Array of document paths (relative to basePath) to derive category directories from
 * @returns Map of category path (e.g., 'getting-started') to metadata
 */
export const buildCategoryMetadataMap = (
  basePath: string,
  docPaths: readonly string[],
): Map<string, CategoryMetadata> => {
  const metadataMap = new Map<string, CategoryMetadata>()

  // Extract unique directory paths from document paths
  const extractDirectories = R.pipe(
    R.map((docPath: string) => {
      const parts = docPath.split('/')
      // Build all parent directory paths
      const dirs: string[] = []
      for (let pathIndex = 1; pathIndex < parts.length; pathIndex++) {
        dirs.push(parts.slice(0, pathIndex).join('/'))
      }
      return dirs
    }),
    R.flatten,
    R.uniq,
  )

  const directories = extractDirectories(docPaths) as string[]

  for (const dirPath of directories) {
    const fullPath = join(basePath, dirPath)
    const metadata = readCategoryMetadata(fullPath)
    if (metadata) {
      metadataMap.set(dirPath, metadata)
    }
  }

  return metadataMap
}

/**
 * Clear the category metadata cache.
 * Useful for testing or when files have changed.
 */
export const clearCategoryMetadataCache = (): void => {
  categoryMetadataCache.clear()
}
