---
import { i18n } from 'astro:config/server'
import { type CollectionKey, getCollection, render } from 'astro:content'
import { docsConfigs } from 'virtual:shipyard-docs-configs'
import type { NavigationTree } from '@levino/shipyard-base'
import {
  Breadcrumbs,
  DeprecationBanner,
  TableOfContents,
  VersionBadge,
  VersionSelector,
} from '@levino/shipyard-base/components'
import BaseLayout from '@levino/shipyard-base/layouts/Page.astro'
import { experimental_AstroContainer as AstroContainer } from 'astro/container'
import { Array as EffectArray, Option } from 'effect'
import { getPaginationInfo } from '../src/pagination'
import type { DocsData } from '../src/sidebarEntries'
import { filterDocsForVersion, toSidebarEntries } from '../src/sidebarEntries'
import DocMetadata from './DocMetadata.astro'
import DocPagination from './DocPagination.astro'
import LlmsTxtSidebarLabel from './LlmsTxtSidebarLabel.astro'

interface Props {
  headings?: { depth: number; text: string; slug: string }[]
  /**
   * The base path for generating doc URLs.
   * @default 'docs'
   */
  routeBasePath?: string
  /**
   * Pre-computed docs data for the sidebar. If provided, this will be used
   * instead of fetching from the default 'docs' collection.
   * Use this when you have multiple docs instances with different collections.
   */
  docsData?: DocsData[]
  /**
   * URL to edit this page in the repository.
   */
  editUrl?: string
  /**
   * The date when this page was last updated.
   */
  lastUpdated?: Date
  /**
   * The name of the author who last updated this page.
   */
  lastAuthor?: string
  /**
   * The current version being viewed (for versioned docs).
   * If not provided, it will be extracted from the URL.
   */
  currentVersion?: string
}

const {
  headings = [],
  routeBasePath = 'docs',
  docsData,
  editUrl,
  lastUpdated,
  lastAuthor,
  currentVersion: currentVersionProp,
} = Astro.props

// Normalize the route base path
const normalizedBasePath = routeBasePath.replace(/^\/+|\/+$/g, '')

// Get version configuration for this docs instance
const versionsConfig = docsConfigs[normalizedBasePath]?.versions

// Extract current version from URL if not provided via props
// URL patterns: /docs/v1.0/... or /en/docs/v1.0/...
const extractVersionFromUrl = (): string | undefined => {
  if (!versionsConfig) return undefined

  const path = Astro.url.pathname
  const basePath = normalizedBasePath

  // Find the segment after the base path
  // Handle both /docs/v1.0/... and /en/docs/v1.0/...
  const basePathIndex = path.indexOf(`/${basePath}/`)
  if (basePathIndex === -1) return undefined

  const afterBasePath = path.substring(basePathIndex + basePath.length + 2)
  const nextSegment = afterBasePath.split('/')[0]

  // Handle 'latest' alias - resolve to current version
  if (nextSegment === 'latest') {
    return versionsConfig.current
  }

  // Check if this segment matches a known version path
  const matchingVersion = versionsConfig.available.find(
    (v) => v.path === nextSegment || v.version === nextSegment,
  )

  return matchingVersion?.version
}

const currentVersion = currentVersionProp ?? extractVersionFromUrl()

// Get the collection name from config, defaulting to the route base path
const collectionName =
  docsConfigs[normalizedBasePath]?.collectionName ?? normalizedBasePath

const getPath = (id: string) => {
  // Remove the .md extension if present and handle index pages
  const cleanId = id.replace(/\.md$/, '')
  const isIndex = cleanId.endsWith('/index') || cleanId === 'index'

  if (i18n) {
    // For i18n, slice off the locale prefix (e.g., 'en/')
    const pathPart = cleanId.slice(3)
    const finalPath = isIndex ? pathPart.replace(/\/?index$/, '') : pathPart
    return `/${Astro.currentLocale}/${normalizedBasePath}/${finalPath}`
  }

  const finalPath = isIndex ? cleanId.replace(/\/?index$/, '') : cleanId
  return `/${normalizedBasePath}/${finalPath}`
}

// Use provided docsData or fetch from the configured collection
const docs =
  docsData ??
  (await getCollection(collectionName as CollectionKey)
    .then(
      EffectArray.map(async (doc) => {
        const {
          id,
          data: {
            title,
            sidebar: { render: shouldBeRendered, label },
            sidebar_position,
            sidebar_label,
            sidebar_class_name,
            sidebar_custom_props,
            pagination_next,
            pagination_prev,
          },
        } = doc
        return {
          id,
          path: getPath(id),
          title:
            label ??
            title ??
            Option.getOrUndefined(
              EffectArray.findFirst(
                (await render(doc)).headings,
                ({ depth }) => depth === 1,
              ),
            )?.text ??
            id,
          link: shouldBeRendered,
          sidebarPosition: sidebar_position,
          sidebarLabel: sidebar_label,
          sidebarClassName: sidebar_class_name,
          sidebarCustomProps: sidebar_custom_props,
          pagination_next,
          pagination_prev,
        }
      }),
    )
    .then((promises) => Promise.all(promises)))

// Filter docs by version for sidebar if versioning is enabled
// This ensures the sidebar only shows docs from the current version
const sidebarDocs =
  currentVersion && versionsConfig
    ? filterDocsForVersion(docs, currentVersion)
    : docs

const fullTree = toSidebarEntries(sidebarDocs)

const entries: NavigationTree =
  i18n && Astro.currentLocale
    ? (fullTree[Astro.currentLocale]?.subEntry ?? {})
    : fullTree

// Compute pagination info for the current page BEFORE adding llms.txt
// (llms.txt should not be part of pagination navigation)
// Use sidebarDocs for versioned docs to keep pagination within the same version
const pagination = getPaginationInfo(Astro.url.pathname, entries, sidebarDocs)

// Add llms.txt link to sidebar if enabled for this docs instance
// This is added AFTER pagination computation so it doesn't affect prev/next navigation
const docsConfig = docsConfigs[normalizedBasePath]
const llmsTxtHref = `/${normalizedBasePath}/llms.txt`
// Render the LlmsTxtSidebarLabel component to HTML using Astro Container
if (docsConfig?.llmsTxtEnabled) {
  const container = await AstroContainer.create()
  const llmsTxtLabelHtml = await container.renderToString(LlmsTxtSidebarLabel, {
    props: { href: llmsTxtHref },
  })
  entries['llms.txt'] = {
    labelHtml: llmsTxtLabelHtml,
  }
}

// Prepare version selector props (only if versions are configured)
const hasVersions = versionsConfig && versionsConfig.available.length > 1
const versionSelectorProps = hasVersions
  ? {
      versions: versionsConfig.available,
      currentVersion: currentVersion ?? versionsConfig.current,
      stableVersion: versionsConfig.stable,
      deprecatedVersions: versionsConfig.deprecated,
    }
  : null

// Prepare version badge props (show if versioning is enabled)
const versionBadgeProps =
  versionsConfig && currentVersion
    ? {
        version: currentVersion,
        stableVersion: versionsConfig.stable,
        currentVersion: versionsConfig.current,
        deprecatedVersions: versionsConfig.deprecated,
        banner: versionsConfig.available.find(
          (v) => v.version === currentVersion,
        )?.banner,
        isLatestAlias: Astro.url.pathname.includes('/latest/'),
      }
    : null

// Check if current version is deprecated
const isDeprecated =
  versionsConfig &&
  currentVersion &&
  (versionsConfig.deprecated?.includes(currentVersion) ||
    versionsConfig.available.find((v) => v.version === currentVersion)
      ?.banner === 'unmaintained')

// Prepare deprecation banner props (show only for deprecated versions)
// This block only executes when isDeprecated is true, which guarantees versionsConfig and currentVersion exist
const deprecationBannerProps =
  isDeprecated && versionsConfig && currentVersion
    ? (() => {
        // Find the current version info
        const currentVersionInfo = versionsConfig.available.find(
          (v) => v.version === currentVersion,
        )
        // Find the latest version info
        const latestVersionInfo = versionsConfig.available.find(
          (v) => v.version === versionsConfig.current,
        )
        // Build the URL to the same page in the latest version
        const currentPath = Astro.url.pathname
        const currentVersionPath = currentVersionInfo?.path ?? currentVersion
        const latestVersionPath =
          latestVersionInfo?.path ?? versionsConfig.current
        // Escape special regex characters in the version path
        const escapedVersionPath = currentVersionPath.replace(
          /[.*+?^${}()|[\]\\]/g,
          '\\$&',
        )
        const latestVersionUrl = currentPath.replace(
          new RegExp(`/${escapedVersionPath}/`),
          `/${latestVersionPath}/`,
        )

        return {
          version: currentVersion,
          label: currentVersionInfo?.label,
          currentVersion: versionsConfig.current,
          currentVersionLabel: latestVersionInfo?.label,
          latestVersionUrl,
        }
      })()
    : null
---

<BaseLayout sidebarNavigation={entries}>
  {
    versionSelectorProps && (
      <VersionSelector
        slot="navbarExtra"
        variant="dropdown"
        {...versionSelectorProps}
      />
    )
  }
  {
    versionSelectorProps && (
      <VersionSelector
        slot="sidebarExtra"
        variant="list"
        {...versionSelectorProps}
      />
    )
  }
  <div class="grid grid-cols-12 gap-6 max-w-7xl mx-auto">
    <div class="col-span-12 xl:col-span-9">
      {deprecationBannerProps && (
        <div class="not-prose mb-4">
          <DeprecationBanner {...deprecationBannerProps} />
        </div>
      )}
      <div class="prose max-w-none">
        <div class="flex items-center gap-3 flex-wrap not-prose mb-2">
          <Breadcrumbs navigation={entries} />
          {versionBadgeProps && (
            <VersionBadge {...versionBadgeProps} size="sm" />
          )}
        </div>
        <TableOfContents links={headings} class="xl:hidden" />
        <slot />
        <DocMetadata editUrl={editUrl} lastUpdated={lastUpdated} lastAuthor={lastAuthor} />
        <DocPagination prev={pagination.prev} next={pagination.next} />
      </div>
    </div>
    <div class="hidden xl:block col-span-3">
      <div class="sticky top-20 max-h-[calc(100vh-6rem)] overflow-y-auto">
        <TableOfContents links={headings} desktopOnly />
      </div>
    </div>
  </div>
</BaseLayout>
